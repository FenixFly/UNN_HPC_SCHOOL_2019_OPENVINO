# Практика 1. Инструменты разработки ПО и знакомство с OpenCV

## Цели

__Цель данной работы__ - освоить следующие инструменты 
разработки программного обеспечения:

  - Система контроля версий [Git](https://git-scm.com/book/en/v2)
  - Консоль Python
  - Библиотека OpenCV
  
## Задачи

__Основные задачи__

  1. Создать серверную копию рабочего репозитория, содержащего
     практические задания школы
  1. Создать локальную копию (на рабочей машине) репозитория, содержащего
     практические задания школы
  1. Настроить локальную копию репозитория для последующей синхронизации с сервером
  1. Установить необходимые необходимые библиотеки
  1. Разработать:
	  1. приложение для открытия исходного изображения из файла и сохранения результирующего изображения в файл
	  1. фильтр для перевода изображения в оттенки серого
	  1. фильтр для изменения размера изображения
      1. фильтр для вырезания квадрата из центральной части изображения
  1. Сделать "commit"(зафиксировать) разработанные методы в локальном репозитории.
  1. Отправить "pull request" в основной репозиторий, содержащий шаблоны
     практических заданий школы.

__Дополнительные задачи__
  1. Разработать приложение для открытия изображение/видео/видеопотока с веб-камеры и вывода данных на экран

## Общая последовательность действий

  1. Сделать форк upstream-репозитория
  1. Клонировать origin-репозиторий к себе на локальную машину (раздел
     [Общие инструкции по работе с Git][git-intro])
  1. Собрать проект и проверить его работоспособность, запустив пример
     (раздел [Сборка проекта с помощью CMake и MS VS][cmake-msvs])
  1. Создать рабочую ветку (раздел [Общие инструкции по работе с Git][git-intro])
  1. Реализовать отображение картинки на экране при помощи OpenCV
     По мере готовности не забывайте выкладывать изменения в рабочую ветку на сервер
  1. Реализовать фильтр, который будет переводить изображение в оттенки серого
  1. Реализовать фильтр, который будет обрезать изображение
  1. Реализовать фильтр, который будет изменять размер изображения  
  1. Сделать Pull Request в upstream-репозиторий
  1. Решить задачи списка [Дополнительные задачи][tasks]
  
  ## Детальная инструкция по выполнению работы

  1. Сделать форк upstream-репозитория.
  
     1. Открыть в браузере upstream-репозиторий
        https://github.com/itlab-vision/UNN-HPC-SCHOOL-2019-OPENVINO
     1. В правом верхнем углу нажать кнопку Fork
     1. Выбрать в качестве организации, куда направить форк, организацию,
        соответствующую вашему аккаунту `@github-account`

  1. Клонировать origin-репозиторий к себе на локальную машину (раздел
     [Общие инструкции по работе с Git][git-intro])
     
     1. Открыть командную строку Git Bash (или Git Shell в зависимости от того,
        какой git-клиент установлен на вашей машине). Для этого необходимо найти
        соответствующий ярлык на рабочем столе или в меню "Пуск".
     1. Воспользоваться перечнем инструкций, описанных в разделе
        [Общие инструкции по работе с Git][git-intro]).		
 
   1. Удостовериться, что все семпл работает - запустить командную строку, в ней выполнить файл вашего семпла

            ```bash
            $ cd UNN-HPC-SCHOOL-2019/samples
            $ python practice1_template.py
            ```
	 
  1. Создать рабочую ветку (раздел [Общие инструкции по работе с Git][git-intro]).
  
  1. Создать копию файла `<project_source>/samples/practice1_template.py` и назвать ее `<project_source>/samples/practice1_YOUR_NAME.py`
  
  1. В файле `practice1_YOUR_NAME.py` добавить чтение параметров командной строки при помощи библиотеки `argparse`. В семпле уже добавлен код, который создает обработчик для чтения параметров командной строки, вам нужно реализовать добавление новых параметров 
  
  1. В файле `practice1_YOUR_NAME.py` реализовать чтение файла изображения при помощи имени файла, полученного из аргументов командной строки, и вывести это изображение на экран.  [Шпаргалка по OpenCV в Python][opencv-python-guide]
  
  1. Релизовать фильтры:
	  1. В файле `imagefilter.py` написать реализацию метода `process_image`. 
	  1. Для перевода изображения в оттенки серого используйте фукнцию [`cvtColor`][cvtcolor]
	  1. Для изменения размера изображения используйте функцию [`cvResize`][cvresize]
      1. Для обрезки изображения вычислите центр изображения и максимальную сторону квадрата, которую можно получить из начального изображения, а затем сделайте срез изображения подобно тому, как делаются срезы массивов в [`numpy`][numpy-slice-list]    
  
  1. Прислать Pull Request с внесенными изменениями. Пометить в конце названия `(NOT READY)`. По мере готовности решений основных задач Pull Request можно будет переименовать.
  
  1. Решить задачи списка [Дополнительные задачи][tasks].

  
## Общие инструкции по работе с Git

В данном разделе описана типичная последовательность действий, которую
необходимо выполнить перед тем, как начать работать с проектом. Далее
для определенности используется репозиторий `CV-SUMMER-CAMP`.

  1. Создать аккаунт на [github.com](https://github.com), если такой
     отсутствует. Для определенности обозначим аккаунт `github-account`.

  1. Сделать fork репозитория
     <https://github.com/itlab-vision/UNN-HPC-SCHOOL-2019-OPENVINO> (в
     терминологии Git upstream-репозиторий) к себе в личный профиль с названием
     `github-account`. В результате будет создана копия репозитория 
     <https://github.com/github-account/UNN-HPC-SCHOOL-2019-OPENVINO>
     (origin-репозиторий).

  1. Клонировать [origin][origin] репозиторий к себе на локальный компьютер,
     воспользовавшись следующей командой:

        ```bash
        $ git clone https://github.com/   <github-account>   /UNN-HPC-SCHOOL-2019-OPENVINO
        ```

  1. Перейти в директорию `UNN-HPC-SCHOOL-2019-OPENVINO`:

        ```bash
        $ cd ./CV-SUMMER-CAMP
        ```

  1. Настроить адрес upstream-репозитория (потребуется при обновлении локальной
     версии репозитория):

        ```bash
        $ git remote add upstream https://github.com/itlab-vision/UNN-HPC-SCHOOL-2019-OPENVINO
        ```

  1. Настроить имя пользователя и e-mail, из под которого будут выполняться
     все операции с репозиторием Git:

        ```bash
        $ git config --local user.name "github-account"
        $ git config --local user.email "github-email"
        ```

        Примечание: если не выполнить указанную операцию при попытке
        размещения изменений на сервер, они попадут под аккаунтом пользователя
        компьютера.
  
  1. Настроить редактор, который будет использован, если вносятся изменения
     в историю репозитория (в частности, при слиянии веток).
  
        ```bash
        $ git config --local core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -n -w"
        ```
        
        Когда сделан форк репозитория у вас создается по умолчанию единственная ветка
        master. Тем не менее, при решении независимых задач следует создавать рабочие
        ветки. Далее показаны основные команды для управления ветками на примере ветки
        `practice-1`.

  1. Получить список веток:

        ```bash
        $ git branch [-v]
        # [-v] - список с информацией о последних коммитах
        ```

  1. Создать ветку:

        ```bash
        $ git branch practice-1
        ```

  1. Создать ветку `practice-1` и перейти в нее:

        ```bash
        $ git checkout [-b] practice-1
        # [-b] - создание и переход в ветку <branch_name>
        ```
  1. Удалить ветку в локальном репозитории:

        ```bash
        $ git branch -d <branch_name>
        ```

  1. Удалить ветку на сервере:

        ```bash
        $ git push [remotename] :[branch]
        # [remotename] - имя удалённого репозитория. Если следовать приведённой
        #     инструкции, то origin - репозиторий пользователя github-account, upstream -
        #     репозиторий itlab-vision/UNN-HPC-SCHOOL-2019-OPENVINO
        ```

При работе с файлами в ветке необходимо управлять изменениями. Далее приведен
перечень основных команд в предположении, что текущей рабочей веткой
        является `practice-1`.

  1. Получить список текущих изменений:

        ```bash
        $ git status
        ```

  1. Пометить файл как добавленный в текущую ветку репозитория (файл будет
     добавлен после выполнения команды `commit`):

        ```bash
        $ git add [<file_name>]
        # <file_name> - название файла для добавления в commit
        #     если вместо имени указан символ *, то будут добавлены все новые файлы,
        #     не совпадающие с масками, указанными в .gitignore
        ```

  1. Добавить изменения в текущую ветку локального репозитория:

        ```bash
        $ git commit [-m "<message_to_commit>"] [-a]
        # [-a] - автоматически добавляет изменения для существующих на сервере файлов
        #     без выполнения команды git add
        # [--amend] - перезаписывает последний коммит (используется, если не забыты
        #     изменения)
        ```

  1. Разместить изменения, которые были добавлены в локальный репозиторий
     с помощью команды `commit`:

        ```bash
        $ git push [-u] origin [practice-1]
        # [-u] - отслеживать версию ветки [practice-1] на удалённом сервере
        #     (origin). Позволяет получать изменения с сервера при помощи команды git pull
        #     без явного указания имени удалённого репозитория и имени ветки.
        ```

  1. Получить изменения с сервера при помощи команды `pull` и слить их с
     отслеживаемыми ветками:

        ```bash
        $ git pull [remotename [<branch name>]]
        ```

  1. Удалить файлы или директории (!без опции `-f` для файлов, состояния
     которых совпадают с состояниям на сервере):

        ```bash
        $ git rm [-f] [--cached]
        # [-f] - принудительное удаление (файла с измененным состоянием)
        # [--cached] - удаление файлов на сервере, но не в локальной директории
        ```

  1. Переименовать файлы (или 3 команды: `mv`, `git rm`, `git add`):

        ```bash
        $ git mv <file_from> <file_to>
        ```

Когда в проекте работает несколько человек, то вполне естественная ситуация -
необходимость слияния изменений и разрешение конфликтов.

  1. Слияние (вариант 1):

        ```bash
        $ git merge upstream/master # слияние изменений из ветки upstream в master
        $ git merge master # слияние изменений из ветки master в текущую ветку
        ```

  1. Слияние (вариант 2):

        ```bash
        $ git checkout <branch_name> # переход в ветку <branch_name> (при необходимости)
        $ git rebase <base_branch> [<branch_name>] # слияние изменений из ветки <base_branch> в ветку <branch_name>
        $ git checkout <base_branch>
        $ git merge <branch_name>
        ```

  1. Инструмент для разрешения конфликтов:

        ```bash
        $ git mergetool
        ```


## Добавление аргументов командной строки в приложение

В файле `practice1_template.py` представлен шаблон функции `build_argparse`, которая используется для разбора аргрументов командной строки, и в которую вам нужно дописать собственные аргументы, такие как путь до изображения, новые размеры изображения и т.д. Параметры описываются следующим образом:  

        ```python
        def build_argparse(): 
            parser=argparse.ArgumentParser()
            
            parser.add_argument('-a1', '--argument1', help='your cmd 
            
            argument', type=str)

        ```
    Где `-a1` - короткое имя аргумента, `--argument1` - полное имя аргумента, `type` - тип аргумента (`int`, `float`, `str` и т.д.)
    Дополнительные параметры:
    - `required=True` (или `False`) - является ли параметр обязательным
    - `default = 'defaultvalue'` - значение параметра по умолчанию
    - `nargs = 2` - позволяет передать два значения через пробел 

Чтение параметров в основной программе происходит по их полному имени:

        ```python
        args = build_argparse().parse_args()
        
        variable = args.argument1 
            
        ```

## Структура исходного кода

  1. В папке `src` расположен файл `imagefilter.py`, который содержит объявление класса `ImageFilter`, в котором будет храниться реализация метода преобразования изображения `process_image`
  1. В папке `samples` расположен файл `practice1_template.py`, в котором представлена функция `main` - точка входа в программу.
 

<!-- LINKS -->
[origin]: https://github.com/itlab-vision/CV-SUMMER-CAMP
[cvtcolor]: https://docs.opencv.org/3.4.2/d7/d1b/group__imgproc__misc.html#ga397ae87e1288a81d2363b61574eb8cab
[cvresize]: https://docs.opencv.org/3.4.2/df/d4e/group__imgproc__c.html#ga1119b1dc4f6db2a393057992ed574e25
[git-intro]: https://github.com/FenixFly/CV-SUMMER-CAMP/blob/dev/docs/README_1.md#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-git
[numpy-slice-list]:https://pythonworld.ru/numpy/2.html
[opencv-python-guide]:https://tproger.ru/translations/opencv-python-guide/
[tasks]: https://github.com/FenixFly/CV-SUMMER-CAMP/blob/dev/docs/README_1.md#%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8
